package eu.assuremoss;

import com.github.difflib.patch.Patch;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;
import eu.assuremoss.framework.api.*;
import eu.assuremoss.framework.model.VulnerabilityEntry;
import eu.assuremoss.framework.modules.src.LocalSourceFolder;
import eu.assuremoss.utils.*;
import eu.assuremoss.utils.factories.PatchCompilerFactory;
import eu.assuremoss.utils.factories.ToolFactory;
import eu.assuremoss.utils.parsers.SpotBugsParser;
import eu.assuremoss.utils.tools.PatchChecker;
import eu.assuremoss.utils.tools.SourceCompiler;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.Matcher;
import java.util.zip.DataFormatException;

import static eu.assuremoss.utils.Configuration.*;
import static eu.assuremoss.utils.Utils.getConfigFile;
import static eu.assuremoss.utils.Utils.getMappingFile;

public class VulnerabilityRepairDriver {
    private static final Logger LOG = LogManager.getLogger(VulnRepairDriver.class);
    private MLogger MLOG;
    public Properties properties;
    public Configuration config;
    private final PatchCompiler patchCompiler;
    private final PathHandler path;
    private final Statistics statistics;

    public static void main(String[] args) throws IOException {
        Configuration config = new Configuration(getConfigFile(args), getMappingFile(args));
        VulnerabilityRepairDriver driver = new VulnerabilityRepairDriver(config, config.properties);
        driver.bootstrap();
    }

    public VulnerabilityRepairDriver(Configuration config, Properties properties) throws IOException {
        this.patchCompiler = PatchCompilerFactory.getPatchCompiler(properties.getProperty(PROJECT_BUILD_TOOL_KEY));
        this.path = new PathHandler(properties);
        this.config = config;
        this.statistics = new Statistics(path);
        this.properties = properties;

        Utils.initResourceFiles(properties, path);
        MLOG = new MLogger(properties, path.logFile(), path);
    }

    public void bootstrap() {
        MLOG.fInfo("Start!");

        // 0. Setup
        Date startTime = new Date();
        String startTimeStr = new SimpleDateFormat("yyyy.MM.dd.HH.mm.ss").format(startTime);

        // 1. Get source code
        MLOG.info("Project source acquiring started");
        SourceCodeCollector scc = new LocalSourceFolder(properties.getProperty(PROJECT_PATH_KEY));
        scc.collectSourceCode();

        // 2. Source compilation
        MLOG.info("Project compilation started");
        String workingDir = Paths.get(properties.getProperty("config.results_path")).toString();
        SourceCompiler compiler = new SourceCompiler(properties, false);

        compiler.compile (scc.getSourceCodeLocation(),  Configuration.isTestingEnabled(properties), false);

        String spotBugsXml = path.spotbugsXML(false);
        compiler.analyze();

        // 3. Produces :- vulnerability locations
        MLOG.info("Spotbugs analysis started");

        SpotBugsParser sparser = new SpotBugsParser(path, config.properties);
        List<VulnerabilityEntry> vulnerabilityLocations = null;
        try {
            vulnerabilityLocations = sparser.readXML(false, true);
        } catch (DataFormatException e) {
            e.printStackTrace();
        }
        if (vulnerabilityLocations == null) {
            vulnerabilityLocations = new ArrayList<>();
        }
        statistics.saveVulnerabilityStatistics(vulnerabilityLocations);

        if (vulnerabilityLocations.size() == 0) {
            MLOG.ninfo("Framework repair finished!");
            return;
        }

        // == Transform code / repair ==
        Map<String, List<JSONObject>> problemFixMap = new HashMap<>();

        int vulnIndex = 0;
        for (VulnerabilityEntry vulnEntry : vulnerabilityLocations) {
            // - Init -
            String cuName = vulnEntry.getClassName().replaceAll("\\.", Matcher.quoteReplacement(File.separator));
            String jsiName = String.valueOf(Paths.get(path.asgDir(), cuName+".jsi"));
            VulnerabilityRepairer vulnRepairer = ToolFactory.createASGTransformRepair(properties, jsiName);

            vulnIndex++;
            //if (vulnIndex!=9) continue;

            MLogger buildLogger = new MLogger(path.vulnBuildLogFile(vulnIndex));
            MLogger.setActiveLogger(buildLogger);
            // - Skip if column info was not retrieved -
            if (vulnEntry.getStartCol() == -1 && vulnEntry.getEndCol() == -1) {
                buildLogger.ninfo(String.format("No column info were retrieved, skipping vulnerability %d/%d", vulnIndex, vulnerabilityLocations.size()));
                continue;
            }

            // - Generate repair patches -
            buildLogger.ninfo(String.format("Generating patches for vulnerability %d/%d", vulnIndex, vulnerabilityLocations.size()));
            List<Pair<File, Pair<Patch<String>, String>>> patches = vulnRepairer.generateRepairPatches(scc.getSourceCodeLocation(), vulnEntry, null);
            vulnEntry.setGeneratedPatches(patches.size());

            //  - Testing Patches - Apply & Compile & Analyze patches
            buildLogger.info(String.format("Verifying patches for vulnerability %d/%d", vulnIndex, vulnerabilityLocations.size()));
            PatchChecker validator = new PatchChecker(path);
            List<Pair<File, Pair<Patch<String>, String>>> candidatePatches = validator.getCandidatePatches(properties, scc, vulnEntry, sparser, patches);
            vulnEntry.setVerifiedPatches(candidatePatches.size());

            // - Save patches -
            Utils.createDirectory(patchSavePath(properties));
            if (candidatePatches.isEmpty()) {
                buildLogger.info("No patch candidates were found, skipping!");
                continue;
            }

            buildLogger.info(String.format("Writing out candidate patches for vulnerability %d/%d", vulnIndex, vulnerabilityLocations.size()));
            if (!problemFixMap.containsKey(vulnEntry.getType())) {
                problemFixMap.put(vulnEntry.getType(), new ArrayList());
            }
            problemFixMap.get(vulnEntry.getType()).add(validator.generateFixEntity(properties, vulnEntry, candidatePatches));
            buildLogger.closeFile();
        }

        MLogger.setActiveLogger(MLOG);

        JSONObject vsCodeConfig = getVSCodeConfig(problemFixMap);

        try (FileWriter fw = new FileWriter(String.valueOf(Paths.get(patchSavePath(properties), "vscode-config.json")))) {
            Gson gson = new GsonBuilder().setPrettyPrinting().create();
            JsonElement element = JsonParser.parseString(vsCodeConfig.toJSONString());
            fw.write(gson.toJson(element));
        } catch (IOException e) {
            e.printStackTrace();
        }

        if (archiveEnabled(properties)) {
            Utils.archiveResults(patchSavePath(properties), properties.getProperty(ARCHIVE_PATH), descriptionPath(properties), startTimeStr);
        }

        Utils.deleteIntermediatePatches(patchSavePath(properties));
        Utils.saveElapsedTime(startTime);
        statistics.createResultStatistics(vulnerabilityLocations);

        MLOG.info("Framework repair finished!");
        MLOG.closeFile();
    }

    private JSONObject getVSCodeConfig(Map<String, List<JSONObject>> problemFixMap) {
        JSONObject vsCodeConfig = new JSONObject();
        for (String problemType : problemFixMap.keySet()) {
            JSONArray fixesArray = new JSONArray();
            fixesArray.addAll(problemFixMap.get(problemType));
            vsCodeConfig.put(problemType, fixesArray);
        }
        return vsCodeConfig;
    }
}
