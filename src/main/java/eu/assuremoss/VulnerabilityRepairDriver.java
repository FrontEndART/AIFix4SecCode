package eu.assuremoss;

import com.github.difflib.patch.Patch;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;
import eu.assuremoss.framework.api.*;
import eu.assuremoss.framework.model.CodeModel;
import eu.assuremoss.framework.model.VulnerabilityEntry;
import eu.assuremoss.framework.modules.src.LocalSourceFolder;
import eu.assuremoss.utils.*;
import eu.assuremoss.utils.factories.PatchCompilerFactory;
import eu.assuremoss.utils.factories.ToolFactory;
import eu.assuremoss.utils.parsers.SpotBugsParser;
import eu.assuremoss.utils.patchPrioritizer.CodeSimilarityAlgorithm;
import eu.assuremoss.utils.patchPrioritizer.PatchPrioritizer;
import eu.assuremoss.utils.tools.PatchChecker;
import eu.assuremoss.utils.tools.SourceCompiler;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.net.URI;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.Matcher;
import java.util.zip.DataFormatException;

import static eu.assuremoss.utils.Configuration.*;
import static eu.assuremoss.utils.Utils.*;

public class VulnerabilityRepairDriver {
    private static final Logger LOG = LogManager.getLogger(VulnRepairDriver.class);
    private MLogger MLOG;
    public Properties properties;
    public Configuration config;
    private final PatchCompiler patchCompiler;
    private final PathHandler path;
    private final Statistics statistics;
    private final String cu;

    public static void main(String[] args) throws IOException {
        Configuration config = new Configuration(getConfigFile(args), getMappingFile(args));
        VulnerabilityRepairDriver driver = new VulnerabilityRepairDriver(config, config.properties, getCUFromArguments(args));
        driver.bootstrap();
    }

    public VulnerabilityRepairDriver(Configuration config, Properties properties, String cu) throws IOException {
        this.patchCompiler = PatchCompilerFactory.getPatchCompiler(properties.getProperty(PROJECT_BUILD_TOOL_KEY));
        this.path = new PathHandler(properties.getProperty(RESULTS_PATH_KEY), properties.getProperty(VALIDATION_RESULTS_PATH_KEY));
        this.config = config;
        this.statistics = new Statistics(path);
        this.properties = properties;
        this.cu = cu;

        Utils.initResourceFiles(properties, path);
        MLOG = new MLogger(LOG_TXT, path, Configuration.isTestingEnabled(properties));
    }

    public void bootstrap() {
        MLOG.fInfo("Start!");

        // 0. Setup
        Date startTime = new Date();
        String startTimeStr = new SimpleDateFormat("yyyy.MM.dd.HH.mm.ss").format(startTime);

        // 1. Get source code
        MLOG.info("Project source acquiring started");
        SourceCodeCollector scc = new LocalSourceFolder(properties.getProperty(PROJECT_PATH_KEY));
        scc.collectSourceCode();

        // 2. Source compilation
        MLOG.info("Project compilation started");
        String workingDir = Paths.get(properties.getProperty(RESULTS_PATH_KEY)).toString();
        SourceCompiler compiler = new SourceCompiler(properties, false);

        if (cu == null)
            compiler.compile (scc.getSourceCodeLocation(),  Configuration.isTestingEnabled(properties), false);
        else {
            compiler.compile (scc.getSourceCodeLocation(),  properties, false, cu);
        }

        String spotBugsXml = path.spotbugsXML(false);
        compiler.analyze();

        // 3. Produces :- vulnerability locations
        MLOG.info("Spotbugs analysis started");

        SpotBugsParser sparser = new SpotBugsParser(path, config.properties);
        List<VulnerabilityEntry> vulnerabilityLocations = null;
        try {
            vulnerabilityLocations = sparser.readXML(false, true);
        } catch (DataFormatException e) {
            e.printStackTrace();
        }
        if (vulnerabilityLocations == null) {
            vulnerabilityLocations = new ArrayList<>();
        }
        statistics.saveVulnerabilityStatistics(vulnerabilityLocations);

        if (vulnerabilityLocations.size() == 0) {
            MLOG.ninfo("Framework repair finished!");
            try (FileWriter listfile = new FileWriter(properties.getProperty(JSONS_LISTFILE))) {
            } catch (IOException e) {
                e.printStackTrace();
            }
            return;
        }

        // == Transform code / repair ==
        Map<String, Map<String, List<JSONObject>>> problemFixMapsPerCU = new HashMap <>();
        PatchPrioritizer patchPrioritizer = new PatchPrioritizer(new CodeSimilarityAlgorithm());

        int vulnIndex = 0;

        for (VulnerabilityEntry vulnEntry : vulnerabilityLocations) {
            // - Init -
            String cuName = vulnEntry.getClassName().replaceAll("\\.", Matcher.quoteReplacement(File.separator));
            String jsiName = String.valueOf(Paths.get(path.asgDir(), cuName+".jsi"));
            VulnerabilityRepairer vulnRepairer = ToolFactory.createASGTransformRepair(properties, jsiName);

            vulnIndex++;
            //if (vulnIndex>2) continue;

            MLogger buildLogger = new MLogger(path.vulnBuildLogFile(vulnIndex));
            MLogger.setActiveLogger(buildLogger);
            // - Skip if column info was not retrieved -
            if (vulnEntry.getStartCol() == -1 && vulnEntry.getEndCol() == -1) {
                buildLogger.ninfo(String.format("No column info were retrieved, skipping vulnerability %d/%d", vulnIndex, vulnerabilityLocations.size()));
                continue;
            }

            // - Generate repair patches -
            buildLogger.ninfo(String.format("Generating patches for vulnerability %d/%d", vulnIndex, vulnerabilityLocations.size()));
            List<Pair<File, Pair<Patch<String>, String>>> patches = vulnRepairer.generateRepairPatches(scc.getSourceCodeLocation(), vulnEntry, null);
            vulnEntry.setGeneratedPatches(patches.size());

            //  - Testing Patches - Apply & Compile & Analyze patches
            buildLogger.info(String.format("Verifying patches for vulnerability %d/%d", vulnIndex, vulnerabilityLocations.size()));
            PatchChecker validator = new PatchChecker(path);
            List<Pair<File, Pair<Patch<String>, String>>> candidatePatches = validator.getCandidatePatches(properties, scc, vulnEntry, sparser, patches);
            vulnEntry.setVerifiedPatches(candidatePatches.size());

            // - Prioritize Patches -
            buildLogger.info(String.format("Prioritizing patches for vulnerability %d/%d", vulnIndex, vulnerabilityLocations.size()));
            patchPrioritizer.prioritize(patches); //or patchPrioritizer.prioritize(candidatePatches);

            // - Save patches -
            buildLogger.info(String.format("Writing out %d candidate patches for vulnerability %d/%d", candidatePatches.size(), vulnIndex, vulnerabilityLocations.size()));
            Utils.createDirectory(patchSavePath(properties));
            if (candidatePatches.isEmpty()) {
                buildLogger.info("No patch candidates were found, skipping!");
                continue;
            }
            else {
                if (problemFixMapsPerCU.containsKey(vulnEntry.getPath())) {
                    Map<String, List<JSONObject>> problemFixMap = problemFixMapsPerCU.get(vulnEntry.getPath());
                    if (!problemFixMap.containsKey(vulnEntry.getType())) {
                        problemFixMap.put(vulnEntry.getType(), new ArrayList());
                    }
                    problemFixMap.get(vulnEntry.getType()).add(validator.generateFixEntity(properties, vulnEntry, candidatePatches));
                } else {
                    Map<String, List<JSONObject>> problemFixMap = new HashMap<>();
                    List<JSONObject> list = new ArrayList();
                    list.add(validator.generateFixEntity(properties, vulnEntry, candidatePatches));
                    problemFixMap.put(vulnEntry.getType(), list);
                    problemFixMapsPerCU.put(vulnEntry.getPath(), problemFixMap);
                }
                buildLogger.closeFile();
            }
        }

        MLogger.setActiveLogger(MLOG);

        try (FileWriter listfile = new FileWriter(properties.getProperty(JSONS_LISTFILE))) {
            problemFixMapsPerCU.forEach((key, problemFixMap) ->
            {
                JSONObject vsCodeConfig = getVSCodeConfig(problemFixMap);
                File jsonFile = new File(PathHandler.joinPath(properties.getProperty(RESULTS_PATH_KEY), JSON_DIR, getRelativePath(properties.getProperty(PROJECT_PATH_KEY), key) + ".json"));
                if (!jsonFile.exists()) {
                    File directory = new File(jsonFile.getParent());
                    if (!directory.exists()) directory.mkdirs();
                }

                try (FileWriter fw = new FileWriter(jsonFile.getPath())) {
                    listfile.write(jsonFile.getPath()+"\n");
                    Gson gson = new GsonBuilder().setPrettyPrinting().create();
                    JsonElement element = JsonParser.parseString(vsCodeConfig.toJSONString());
                    fw.write(gson.toJson(element));
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }

        if (archiveEnabled(properties)) {
            Utils.archiveResults(patchSavePath(properties), properties.getProperty(ARCHIVE_PATH), descriptionPath(properties), startTimeStr);
        }

        Utils.deleteIntermediatePatches(patchSavePath(properties));
        Utils.saveElapsedTime(startTime);
        statistics.createResultStatistics(properties, vulnerabilityLocations);

        MLOG.info("Framework repair finished!");
        MLOG.closeFile();
    }

    private static String getRelativePath(String projectBaseDir, String filename) {
        File file = new File(filename);
        if (!file.isAbsolute())
            return filename;
        File dir = new File(projectBaseDir);
        URI uri1 = file.toURI();
        URI uri2 = dir.toURI();
        URI relativePath = uri2.relativize(uri1);
        return relativePath.getPath();
    }

    private JSONObject getVSCodeConfig(Map<String, List<JSONObject>> problemFixMap) {
        JSONObject vsCodeConfig = new JSONObject();
        for (String problemType : problemFixMap.keySet()) {
            JSONArray fixesArray = new JSONArray();
            fixesArray.addAll(problemFixMap.get(problemType));
            vsCodeConfig.put(problemType, fixesArray);
        }
        return vsCodeConfig;
    }
}
